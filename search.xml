<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java并发与线程</title>
    <url>/posts/63871/</url>
    <content><![CDATA[<h1 id="并发与线程"><a href="#并发与线程" class="headerlink" title="并发与线程"></a>并发与线程</h1><h2 id="1、并行和并发的区别？"><a href="#1、并行和并发的区别？" class="headerlink" title="1、并行和并发的区别？"></a>1、并行和并发的区别？</h2><ol>
<li><p><strong>并发</strong>是指两个或多个事件在同一时间段内发生，<strong>并行</strong>是指两个或多个事件在同一时间点上发生</p>
</li>
<li><p><strong>并发</strong>是发生在同一个实体上，所以并发会抢占资源。<strong>并行</strong>不会抢占资源，发生在不同的实体上</p>
<p>并发是为了充分利用处理器 每一个核。</p>
</li>
</ol>
<h2 id="2、线程核进程的区别？"><a href="#2、线程核进程的区别？" class="headerlink" title="2、线程核进程的区别？"></a>2、线程核进程的区别？</h2><p><strong>进程：</strong>是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个<strong>线程</strong>共享资源，减少切换次数，从而效率更高。</p>
<p><strong>线程：</strong>是进程的实体，是cpu调度和分配的基本单位，比程序更小的能独立运行的基本单位，同一进程中的多个线程之间可以并发执行。</p>
<span id="more"></span>

<h2 id="3、如何创建线程？"><a href="#3、如何创建线程？" class="headerlink" title="3、如何创建线程？"></a>3、如何创建线程？</h2><ol>
<li><p>继承<strong>Thread</strong>类创建线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		MyThread mThread1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		MyThread mThread2=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		MyThread myThread3=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		mThread1.start();</span><br><span class="line">		mThread2.start();</span><br><span class="line">		myThread3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现<strong>Runnable()<strong>接口实现多线程，然后重写run()方法（</strong>推荐</strong>）==Runnable避免了单继承的局限性==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-当前剩余票数:&quot;</span>+count--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		MyThread Thread1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		Thread mThread1=<span class="keyword">new</span> <span class="title class_">Thread</span>(Thread1,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		Thread mThread2=<span class="keyword">new</span> <span class="title class_">Thread</span>(Thread1,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">		Thread mThread3=<span class="keyword">new</span> <span class="title class_">Thread</span>(Thread1,<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">		mThread1.start();</span><br><span class="line">		mThread2.start();</span><br><span class="line">		myThread3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>高并发与多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>redis-01</title>
    <url>/posts/36792/</url>
    <content><![CDATA[<h2 id="redisDb"><a href="#redisDb" class="headerlink" title="redisDb"></a>redisDb</h2><p>在server.h文件中，是redis底层的数据库实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">	dict *dict;		<span class="comment">/*存放所有键值对*/</span></span><br><span class="line">	dict *expires;	<span class="comment">/*过期时间处理*/</span></span><br><span class="line">	dict *blocking_keys;	<span class="comment">/*阻塞的API*/</span></span><br><span class="line">	dict *ready_keys;</span><br><span class="line">	dict *watched_keys;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> avg_ttl;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> expires_cursor;</span><br><span class="line">	<span class="built_in">list</span> *defrag_later;</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>c语言中的hashmap</p>
<h3 id="主要说说dict里面如何存储整数的，"><a href="#主要说说dict里面如何存储整数的，" class="headerlink" title="主要说说dict里面如何存储整数的，"></a>主要说说dict里面如何存储整数的，</h3><span id="more"></span>


<p>dict中有两个dictht ht hashtable为了rehash扩容，利用链表解决hash冲突，dictht里面的hash数组，每个元素都存储一个dictEntity,而dictEneity里面的 *val指向一个redisObject</p>
<p><img src="/assets/redis/image-20220929092502781.png" alt="存储结构"></p>
<p>redistribution会根据你存储的数据的值不同，进行不同的编码，操作不同，也会改变值的类型。</p>
<p>redisObject</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> type:<span class="number">4</span>;	<span class="comment">//类型</span></span><br><span class="line">	<span class="type">unsigned</span> encoding:<span class="number">4</span>;	<span class="comment">//编码</span></span><br><span class="line">	<span class="type">unsigned</span> lru:LRU_BITS;	<span class="comment">//持久化</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> refcount;	<span class="comment">//引用计数法，判断是否存货</span></span><br><span class="line">	<span class="type">void</span> *ptr;	<span class="comment">//指向内存中的内存区域</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<h3 id="string编码的设计："><a href="#string编码的设计：" class="headerlink" title="string编码的设计："></a>string编码的设计：</h3><p>redisObject中的指针占8个字节，而整数也是8个字节，于是直接使用指针存储整数，在setCommand方法中有写，</p>
<p><img src="/assets/redis/image-20220929092936578.png" alt="image-20220929092936578"></p>
<p>通过len = sdslen(s)获取的字符串长度，如果小于等于20(带符号的整型20位)。则可以转化为整型，</p>
<p><img src="/assets/redis/image-20220929093231676.png" alt="image-20220929093231676"></p>
<p>随后直接由指针存储整型值</p>
<h2 id="alist"><a href="#alist" class="headerlink" title="alist"></a>alist</h2><p>LPUSH指令表示从右往左存放元素，右边第一个先进，RPUSH表示从左往右存放，</p>
<p>LPOP表示从左往右拿，RPOP：从右往左拿，于是，如果使用LPUSH+LPOP，就是栈的结构，LPUSH+RPOP就是队列的结构。</p>
<p>底层编码是使用 quicklist 结构</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>lbin</title>
    <url>/posts/12819/</url>
    <content><![CDATA[<p>雪花算法</p>
<p>​    在复杂的分布式系统中，需要有一个唯一ID来标识一条数据或消息。</p>
<p>ID生成规则部分硬性要求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、全局唯一：不能出现重复的ID号，</span><br><span class="line">2、趋势递增：在MySQL的InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用Btree的数据结构来存储索引数据，所以主键上应该尽量选择使用有序的主键来保证写入性能</span><br><span class="line">3、单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求</span><br><span class="line">4、信息安全：需要ID无规则不规则</span><br><span class="line">5、含时间戳：这样就能够在开发中快速了解这个分布式id的生成时间</span><br></pre></td></tr></table></figure>

<p>ID号生成系统的可用性要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高可用：发一个获取分布式ID的请求，服务器就要保证99.999%的情况下给我创建一个唯一分布式ID。</span><br><span class="line">低延迟：发一个获取分布式ID的请求，服务器就要快，极速。</span><br><span class="line">高QPS：假如并发一口气10万个创建分布式ID请求同时杀过来，服务器要顶的住且一下子成功创建10万个分布式ID。</span><br></pre></td></tr></table></figure>

<p>一般通用的是UUID，</p>
<p>​    UUID(Universally Unique ldentifer)的标准型式包含32个16进制数字，以连了号分为五段，形式为8-4-4-4-12的36个字符， 示例：550e8400-e29b-41d4-a716-446655440000</p>
<span id="more"></span>

<p>性能非常高：本地生成，没有网络消耗</p>
<p>如果只是考虑唯一性，那就选用它吧</p>
<p>但是，入数据库性能差</p>
<p><strong>为什么无序的UUID会导致入库性能变差呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、无序，无法预测他的生成顺序，不能生成递增有序的数字。首先分布式ID一般都会作为主键， 但是安装MySQL官方推荐主键要尽量越短越好，UUID每一个都很长，所以不是很推荐。</span><br><span class="line"></span><br><span class="line">2、主键，ID作为主键时在特定的环境会存在一些问题。比如做DB主键的场景下，UUID就非常不适用MySQL官方有明确的建议主键要尽量越短越好36个字符长度的UUID不符合要求。</span><br><span class="line"></span><br><span class="line">3、索引，既然分布式ID是主键，然后主键是包含索引的，然后MySQL的索引是通过B+树来实现的，每一次新的UUID数据的插入，为了查询的优化，都会对索引底层的B+树进行修改，因为UUID数据是无序的，所以每一次UUID数据的插入都会对主键地械的B+树进行很大的修改，这一点很不好。 插入完全无序，不但会导致一-些中间节点产生分裂，也会白白创造出很多不饱和的节点，这样大大降低了数据库插入的性能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在<strong>单机</strong>里，数据库的自增ID机制的主要原理是：数据库自增ID和mysql数据库的replace into实现的         （这里replace into和insert功能类似）</p>
<p>不同点在于：replace into首先尝试插入数据库列表中，如果发现表中已经有此行数据(根据主键或唯一索引判断)则先删除，再插入，否则直接插入新数据</p>
<p><font color="red">REPLACE INTO的含义是插入一条记录，如果表中唯一索引的值遇到冲突，则替换老数据</font></p>
<p><strong>集群分布式</strong></p>
<p>基于Redis生成全局ID策略</p>
<p>因为Redis是单线的天生保证原子性，可以使用原子操作INCR和INCRBY来实现</p>
<p>注意：在Redis集群情况下，同样和MySQL一样需要设置不同的增长步长，同时key一定要设置有效期可以使用Redis集群来获取更高的吞吐量。</p>
<p>假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。</p>
<p>各个Redis生成的ID为:</p>
<p>A：1, 6, 11, 16, 21<br>B：2, 7 , 12, 17, 22<br>C：3, 8, 13, 18, 23<br>D：4, 9, 14, 19, 24<br>E：5, 10, 15, 20, 25</p>
<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a><strong>雪花算法</strong></h1><p>Twitter的分布式自增ID算法snowflake</p>
<p>概述</p>
<p>Twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra（由Facebook开发一套开源分布式NoSQL数据库系统）。因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一生成服务。</p>
<p>Twitter的分布式雪花算法SnowFlake ，经测试snowflake 每秒能够产生26万个自增可排序的ID</p>
<ol>
<li><p>Twitter的SnowFlake生成ID能够按照时间有序生成。</p>
</li>
<li><p>SnowFlake算法生成ID的结果是一个64bit大小的整数， 为一个Long型（转换成字符串后长度最多19）。</p>
</li>
<li><p>分布式系统内不会产生ID碰撞（由datacenter和workerld作区分）并且效率较高。</p>
</li>
</ol>
<p>分布式系统中，有一些需要使用全局唯一ID的场景， 生成ID的基本要求：</p>
<ol>
<li>在分布式的环境下必须全局且唯一 。</li>
<li>一般都需要单调递增，因为一般唯一ID都会存到数据库，而Innodb的特性就是将内容存储在主键索引树上的叶子节点而且是从左往右，递增的，所以考虑到数据库性能，一般生成的ID也最好是单调递增。 为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点， 首先他相对比较长， 另外UUID一般是无序的。</li>
<li>可能还会需要无规则，因为如果使用唯一ID作为订单号这种，为了不然别人知道一天的订单量是多少，就需要这个规则。</li>
</ol>
<p>号段解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1bit：</span><br><span class="line"></span><br><span class="line">不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。</span><br><span class="line"></span><br><span class="line">41bit - 时间戳，用来记录时间戳，毫秒级：</span><br><span class="line">41位可以表示2^41 - 1个数字</span><br><span class="line">如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0至2^41 - 1</span><br><span class="line"> ，减1是因为可表示的数值范围是从0开始算的，而不是1。</span><br><span class="line">也就是说41位可以表示2^41 - 1个毫秒的值，转化成单位年则是( 2^41 - 1 ) / (1000 ∗60 ∗ 60 ∗ 24 ∗ 365 ) =69年。</span><br><span class="line"></span><br><span class="line">10bit - 工作机器ID，用来记录工作机器ID：</span><br><span class="line">可以部署在2^10 = 1024个节点，包括5位DataCenterId和5位Workerld。</span><br><span class="line">5位(bit) 可以表示的最大正整数是2^5 − 1 = 31,即可以用0、1、2、3、…31这32个数字，来表示不同的DataCenterld或Workerld。</span><br><span class="line"></span><br><span class="line">12bit - 序列号，用来记录同毫秒内产生的不同id。</span><br><span class="line">12位(bit) 可以表示的最大正整数是2 12 − 1 = 4095 2^&#123;12&#125; - 1 = 40952， 即可以用0、1、2、 3、…4094这4095个数字，来表示同一机器同一时间截(毫秒)内产生的4095个ID序号。</span><br><span class="line">SnowFlake可以保证：</span><br><span class="line"></span><br><span class="line">所有生成的ID按时间趋势递增。</span><br><span class="line">整个分布式系统内不会产生重复id（因为有DataCenterId和Workerld来做区分)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter_Snowflake</span></span><br><span class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</span></span><br><span class="line"><span class="comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0</span></span><br><span class="line"><span class="comment"> * 41位时间戳(毫秒级)，注意，41位时间戳不是存储当前时间的时间戳，而是存储时间戳的差值（当前时间戳 - 开始时间戳)</span></span><br><span class="line"><span class="comment"> * 得到的值），这里的的开始时间戳，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下面程序SnowflakeIdWorker类的startTime属性）。41位的时间戳，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69</span></span><br><span class="line"><span class="comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId</span></span><br><span class="line"><span class="comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间戳)产生4096个ID序号</span></span><br><span class="line"><span class="comment"> * 加起来刚好64位，为一个Long型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowflakeIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/** 开始时间戳 (2015-01-01) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twepoch</span> <span class="operator">=</span> <span class="number">1420041600000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id所占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 支持的最大数据标识id，结果是31 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列在id中占的位数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 机器ID向左移12位 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据标识id向左移17位(12+5) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 时间戳向左移22位(5+5+12) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 工作机器ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据中心ID(0~31) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 毫秒内序列(0~4095) */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上次生成ID的时间戳 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId 工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowflakeIdWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间戳</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 测试 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始：&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="type">SnowflakeIdWorker</span> <span class="variable">idWorker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnowflakeIdWorker</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idWorker.nextId();</span><br><span class="line">            System.out.println(id);</span><br><span class="line"><span class="comment">//            System.out.println(Long.toBinaryString(id));</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束：&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>优缺点</p>
<p>优点：</p>
<ul>
<li><p>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</p>
</li>
<li><p>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</p>
</li>
<li><p>可以根据自身业务特性分配bit位，非常灵活。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。</p>
</li>
<li><p>在单机上是递增的，但是由于设计到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。（此缺点可以认为无所谓，一般分布式ID只要求趋势递增，并不会严格要求递增，90%的需求都只要求趋势递增）</p>
</li>
</ul>
<p>其他补充</p>
<ul>
<li><p>百度开源的分布式唯一ID生成器UidGenerator</p>
</li>
<li><p>美团点评分布式ID生成系统Leaf</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>雪花算法</tag>
      </tags>
  </entry>
  <entry>
    <title>spring框架一</title>
    <url>/posts/60282/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>spring框架都是依赖于反射</p>
<blockquote>
<p>基本原理其实就是通过反射解析类及其类的各种信息，包括构造器、方法及其参数，属性。然后将其封装成bean定义信息类、constructor信息类、method信息类、property信息类，最终放在一个map里，也就是所谓的container，池等等，其实就是个map。。汗。。。。当你写好配置文件，启动项目后，框架会先按照你的配置文件找到那个要scan的包，然后解析包里面的所有类，找到所有含有@bean，@service等注解的类，利用反射解析它们，包括解析构造器，方法，属性等等，然后封装成各种信息类放到一个map里。每当你需要一个bean的时候，框架就会从container找是不是有这个类的定义啊？如果找到则通过构造器new出来（这就是控制反转，不用你new,框架帮你new），再在这个类找是不是有要注入的属性或者方法，比如标有@autowired的属性，如果有则还是到container找对应的解析类，new出对象，并通过之前解析出来的信息类找到setter方法，然后用该方法注入对象（这就是依赖注入）。如果其中有一个类container里没找到，则抛出异常，比如常见的spring无法找到该类定义，无法wire的异常。还有就是嵌套bean则用了一下递归，container会放到servletcontext里面，每次reQuest从servletcontext找这个container即可，不用多次解析类定义。如果bean的scope是singleton，则会重用这个bean不再重新创建，将这个bean放到一个map里，每次用都先从这个map里面找。如果scope是session，则该bean会放到session里面。</p>
</blockquote>
<p>spring为开发者提供一个轻量级开发平台，后续诞生的许多实用框架都是以此为生态基础创建的，</p>
<p>为了降低Java开发的复杂性，</p>
<p>主要有==IOC==和==AOP==两个核心技术，</p>
<span id="more"></span>

<h2 id="IOC："><a href="#IOC：" class="headerlink" title="IOC："></a>IOC：</h2><p>ioc是一种设计思想，别的编程语言也有，spring管理bean对象的一个容器，我们通过使用spring，可以将对象的创建和管理完全交给spring，其中spring就是通过ioc使用配置文件来管理和创建对象。</p>
<blockquote>
<p>创建对象有四种方式：</p>
<p>1、使用new关键字调用对象的构造器</p>
<p>2、使用反射的newInstance()方法</p>
<p>3、使用Object的clone()方法</p>
<p>4、使用对象流ObjectInputStream的readObject()方法读取序列化对象</p>
</blockquote>
<p>ioc又叫控制反转，可以对spring中的对象进行创建和维护，其在spring中的实现就是==DI==(依赖注入)</p>
<p>实现原理就是工程模板+反射机制，其中两大核心接口==<strong>BeanFactory</strong>和<strong>ApplicationContext</strong>==</p>
<p>作用：创建对象，管理对象声明周期，依赖注入，依赖检查，自动装配，回调某些方法</p>
<blockquote>
<p>通过BeanDefinitionReader解析各种文件(xml，properties，yaml，json)，拿到配置信息</p>
<p>下一步通过反射进行实例化，（<del>不用new使用反射是因为，通过反射可以获得对象里面所有属性和成员变量，更加灵活</del>）</p>
<p>PostProcessor(后置处理器)</p>
</blockquote>
<p><img src="/spring.assets/image-20221002155350845.png" alt="image-20221002155350845"></p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean:"></a>Bean:</h2><h3 id="bean是什么："><a href="#bean是什么：" class="headerlink" title="bean是什么："></a>bean是什么：</h3><p>Spring 容器使用依赖注入（DI）来管理==组成一个应用程序的组件==。这些对象被称为 Spring Beans，而这些bean交由IOC容器进行管理和创建</p>
<h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><ul>
<li><p>bean定义：</p>
<ol>
<li>  通过xml文件定义 </bean> 标签</li>
<li>  使用注解@bean定义某个类</li>
<li>  @component注解定义bean，加在类上，通过@componentScan注解来扫描</li>
<li>  通过beanDefintion编程式定义注：有编程式和声明式，beanDefintion属于编程式，上面的注解和xml都属于声明式声明式底层也是依赖beanDefintion新建一个类继承FactoryBean接口</li>
</ol>
</li>
<li><p>通过以上定义并注册到BeanFactory中</p>
</li>
<li><p>进行bean的实例化</p>
</li>
<li><p>属性注入(DI)：会产生循环依赖问题，使用三级缓存解决单例的setter注入。</p>
<ul>
<li><p>可以只使用二级缓存吗？ 不可以，主要是为了生成代理对象。</p>
<p>因为三级缓存中放的是生成具体对象的匿名内部类，他可以生成代理对象，也可以是普通的实例对象。</p>
<p>使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。</p>
<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，<code>BeanPostProcessor</code>去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么多线程环境下可能取到的对象就不一致了。</p>
</li>
</ul>
</li>
<li><p>初始化</p>
</li>
<li><p>销毁</p>
</li>
</ul>
<p>将bean注册</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="/spring.assets/image-20221002160842674.png" alt="image-20221002160842674"></p>
<p><img src="/spring.assets/image-20221002160009900.png" alt="image-20221002160009900"></p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<h3 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）</p>
<p>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。</p>
<p>（2）处理器映射器HandlerMapping（不需要程序员开发）</p>
<p>作用：根据请求的URL来查找Handler</p>
<p>（3）处理器适配器HandlerAdapter</p>
<p>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。</p>
<p>（4）处理器Handler（需要程序员开发）</p>
<p>（5）视图解析器 ViewResolver（不需要程序员开发）</p>
<p>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）</p>
<p>（6）视图View（需要程序员开发jsp）</p>
<p>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p>
<h3 id="常用注解："><a href="#常用注解：" class="headerlink" title="常用注解："></a>常用注解：</h3><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
]]></content>
      <tags>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>共识机制</title>
    <url>/posts/39286/</url>
    <content><![CDATA[<h1 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h1><p>推荐阅读：<a href="https://ethereum.org/zh/developers/docs/scaling/sidechains/#consensus-algorithms">学习以太坊</a></p>
<h2 id="1、拜占庭将军问题"><a href="#1、拜占庭将军问题" class="headerlink" title="1、拜占庭将军问题"></a>1、拜占庭将军问题</h2><p>9个将军代表国家参与打仗，现在面对同一场战役，需要9个将军的意见一致达成==共识==（进攻/撤退）。如何达成这种要求。（9个将军互不信任）</p>
<p>首先，最简单的是进行投票，每个将军将自己的投票结果传递给其他将军处，当所有将军都收到投票结果以后才下达最终命令。比如5进攻4撤退，最终结果是进攻。</p>
<p>以上有形成一个问题。当将军中出现了叛徒，对不同的将军传达不同的消息==破坏整体决定的一致性==。</p>
<p>根据相关研究，得出一个【一般性的结论】：<strong>如果叛徒的数量大于或等于三分之一 ，那么拜占庭问题不可解</strong>，这个三分之一也被称为<strong>拜占庭容错</strong>，三模冗余是完全无法容错的（也就是说无解，不可能保持一致性）。</p>
<span id="more"></span>



<hr>
<p>这里我们不考虑传令官路上死亡或者叛变的情况，只对于将军中出现的叛考虑，也就是说如何防止<strong>间谍</strong>对于整体的决策进行干预</p>
<p>构建以下图形</p>
<p><img src="/assets/blockchain/BlockChain.png"></p>
<p>每个将军都保留一个本地记录（账本），用来记录所有将军的决策。</p>
<p>然后构造以下协议：</p>
<ul>
<li>使用将军手写签名保证身份的可靠性（<strong>数字签名</strong>）</li>
<li>国王出资，以保证胜利为由，奖励每一个记录所有账本的将军。所有将军参与<strong>挖矿</strong>，挖到新区块就能得到奖励</li>
<li>每一个将军，在账本上得到最新确定的记录包含1-9个将军后，得出自己的最终结论。</li>
</ul>
<p>这个案例在现在网络速度的环境下可以实现。</p>
<p>这里就引出了现在区块链的核心问题：应用场景与代价博弈。你要解决的痛点，到底值不值得这样的花费呢？无论是算力消耗，还是资源消耗，亦或是类似于上述案例中的国王出资（区块链代币价值为负数？），都是一种【代价】。完全的信任是不存在的，只有当造假（走捷径获得利润）的成本远远高于得到的利润，才能取得信任（一致性）。</p>
<h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><hr>
<p>为了使区块链网络达成共识的机制。</p>
<h3 id="工作量证明-pow"><a href="#工作量证明-pow" class="headerlink" title="工作量证明(pow)"></a>工作量证明(pow)</h3><p>假设一个新区块是一个密码锁的保险箱，第一个解出正确的密码才能打开。理论上，实验的密码次数越多，得出正确的密码概率也就越大，这就是工作量证明。<em><strong>BTC 和 ETH</strong></em> 就是使用的工作量证明。</p>
<p><strong>工作量证明函数</strong></p>
<p>以比特币为例，工作量证明函数使用的hash算法，更多的算力，就意味着挖到新区块的概率越大。</p>
<p><strong>区块</strong></p>
<p>区块利用<strong>merkle</strong>算法，将交易以树的形式进行组合，然后两两进行哈希运算，当为奇数的时候则多算上最后一个交易进行补充，依次进行以叶子节点向根节点的运算，并最终得到根节点的hash值，记录在区块头。</p>
<p><strong>难度值</strong></p>
<p>难度系数主要跟构建区块的预期时间和实际所用时间有关，每个节点会通过难度系数计算下一阶段的难度值，如果如果系数大于1(即区块构建速度大于预期)，难度值将提高；如果系数小于1(即区块构建速度小于预期),难度值降低。也就是说，挖矿难度，不会因为参与的算力增加而变得简单，也就是出矿速度变快。</p>
<p>工作量证明的主要流程就是：首先生成Merkle根哈希     然后组装区块头，接着计算出工作量证明的输出。</p>
<p>最后，生成的符合难度的区块，将通过P2P传递到全网络节点并接收，添加到原有区块链的尾部。</p>
<blockquote>
<p><strong>工作量证明最显著的优点是，它在比特币和其它一些数字货币中已经得到了实践的证明。然而，工作量证明也是有明显缺点的，比如采矿的大量电力消耗和低交易吞吐量。</strong></p>
</blockquote>
<h3 id="权益证明（pos）"><a href="#权益证明（pos）" class="headerlink" title="权益证明（pos）"></a>权益证明（pos）</h3><p>以太坊于 2022 年启动了权益证明机制，这是因为和原先的<a href="https://ethereum.org/zh/developers/docs/consensus-mechanisms/pow/">工作量证明</a>架构相比，以太坊更安全、能耗更低并且更利于实现新的扩容解决方案。</p>
<p>Cardano、Ouroboros、ESO等使用</p>
<p>以保险箱的例子来说，这次把密码锁变为一个彩票系统。购买的彩票越多，则挖到新区块的概率越大。</p>
<p>顾名思义，权益证明，是由矿工的投入数字化货币决定，而不是算力。它的核心思想是将参与者持有的货币数目和持有的时间累计作为共识节点的资本。</p>
<p>具体实施中，权益证明要求所有的参与者抵押一部分他们所拥有的token来验证交易，根据他们所抵押的token占整个网络代币的比例，以及token抵押时长，或者是一些其他的方式以确保他们的利益和整个网络的长期利益是一致的。这样，如果验证者存在欺诈性交易，那么他们所抵押的token也会被削减。</p>
<p>通过长期绑定验证者的利益和整个网络的利益来阻止不良行为，这也不同于工作量证明通过耗费电力来阻止不良行为。</p>
<p>权益证明主要包括两部分：</p>
<ol>
<li><p>验证：</p>
<p>在权益证明中，要求参与者把他们的token作为安全保障金。在整个区块链网络中，参与者会把他们的token投给他们认为有效的区块，如果他们跟网络中的大部分参与者达成一致，就可以获得和他们的token成正比的奖励，而试图作弊，例如同时给两个不同的区块投票，则要冒着失去保证金的⻛险。</p>
<p>可见，在权益证明中，金钱就是力量。</p>
</li>
<li><p>委托：</p>
<p>将自己的token委托给验证者，以换取获得奖励的份额。通常委托人会将token存放在智能合约之中，指定他们想要的委托者。这样当该验证者获得验证奖励的时候，委托人也能获得与其委托的token数量成正比的奖励。</p>
<p>权益证明的优势在于它更经济，可能相比于工作量证明更能有效防止攻击，但是目前还没有在大项目中成熟应用。</p>
</li>
</ol>
<blockquote>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>质押使个人更容易参与其中保障网络的安全，促进去中心化。 验证者节点可以在普通笔记本电脑上运行。 质押池让用户可以在没有 32 个以太币的情况下质押。权益质押更加去中心化。 规模经济不像适用于工作量证明挖矿那样适用于权益证明，权益证明的加密经济安全性高于工作量证明，需要发行较少的新以太币就可以激励网络参与者。</td>
<td>与工作量证明相比，权益证明仍处于起步阶段，并且经过的实践检验较少。实现权益证明比实现工作量证明更加复杂。用户需要运行三种软件才能参与以太坊的权益证明。</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="权威证明"><a href="#权威证明" class="headerlink" title="权威证明"></a>权威证明</h3><p>ETH的Kovan Testnet 和 IBM 的Hyerledger Fabric使用此共识机制</p>
<p>权威证明（PoA）是一种基于声誉的共识算法，为区块链网络（尤其是私有链）引入了实用且有效的解决方案。该术语由以太坊联合创始人兼前首席技术官 Gavin Wood 于2017年提出。</p>
<p>权威证明共识算法运用身份的价值，这意味着，（被选为）区块验证者凭借的不是抵押的加密货币而是个人的信誉。因此权威证明区块链由任意选择的具有可信实体的验证节点保护。</p>
<p>权威证明模型依赖于有限数量的区块验证者，这使其成为高度可扩展的系统。区块和交易都由预先被批准的参与者验证，他们充当系统的管理者。</p>
<p>建立权威必须满足三个主要条件：</p>
<p>  1）必须在链上验证身份(并签署法律文件)</p>
<p>  2）资格很难获得, 目前只能是美国公证人</p>
<p>  3）建立权威时，其检查和程序上必须具有完全的一致性</p>
<p>  被选中的验证者身份信息公布在POA NETWORK主页上。</p>
<p><strong>验证过程</strong></p>
<p>由若干个验证人(validator)来生成区块记录交易，并获得区块奖励和交易费用。在PoA中，验证者（validator）是整个共识机制的关键。 验证者不需要昂贵的网卡，也不需要足够的资产，但它必须具有已知的，并且获得验证的身份。验证者通过放置这个身份来获得担保网络的权力，从而换取区块奖励。若是验证者在整个过程中有恶意行为，或与其它验证者勾结，那通过链上管理可以移除和替换恶意行为者。现有的法律反欺诈保障会被用于整个网络的参与者免受验证者的恶意行为。</p>
<pre><code>   POA网络启动时有12个验证者（现在有20多个），这些验证者通过智能合约来管理，智能合约也加入了治理模式，验证者可以投票添加或删除验证者甚至是更新治理合约。每个验证者出块的几率均等，每产生一个块可以过得一个 POA 币（侧链的原生代币）以及所有的手续费。
</code></pre>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>初识区块链</title>
    <url>/posts/40134/</url>
    <content><![CDATA[<h1 id="初识区块链"><a href="#初识区块链" class="headerlink" title="初识区块链"></a>初识区块链</h1><p>借鉴：<a href="https://zhuanlan.zhihu.com/p/22228902">（一）简单易懂地介绍什么是区块链</a></p>
<h2 id="1、区块链的诞生"><a href="#1、区块链的诞生" class="headerlink" title="1、区块链的诞生"></a>1、区块链的诞生</h2><p>互联网上的贸易，几乎都需要借助可资信赖的第三方信用机构来处理电子支付信息。这类系统仍然内生性地受制于“基于信用的模式”。区块链技术是构建比特币区块链网络与交易信息加密传输的基础技术。它基于密码学原理而不基于信用，使得任何达成一致的双方直接支付，从而不需要第三方中介的参与。</p>
<p>定义：</p>
<blockquote>
<p>区块链是一个分布式账本，一种通过去中心化、去信任的方式集体维护一个可靠数据库的技术方案。</p>
</blockquote>
<p>从数据的角度来看：区块链是一种几乎不可能被更改的分布式数据库。这里的“分布式”不仅体现为数据的分布式存储，也体现为数据的分布式记录（即由系统参与者共同维护）。</p>
<span id="more"></span>

<p>从技术的角度来看：区块链并不是一种单一的技术，而是多种技术整合的结果。这些技术以新的结构组合在一起，形成了一种新的数据记录、存储和表达的方式。</p>
<h2 id="2、区块链的特性"><a href="#2、区块链的特性" class="headerlink" title="2、区块链的特性"></a>2、区块链的特性</h2><ol>
<li><p>开放，共识</p>
<p>任何人都可以参与到区块链网络，每一台设备都能作为一个节点，每个节点都允许获得一份完整的数据库拷贝。节点间基于一套==共识机制==，通过竞争计算共同维护整个区块链。任一节点失效，其余节点仍能正常工作。</p>
</li>
<li><p>去中心，信任</p>
<p>区块链由众多节点共同组成一个端到端的网络，不存在中心化的设备和管理机构。节点之间数据交换通过==数字签名==技术进行验证，无需互相信任，只要按照系统既定的规则进行，节点之间不能也无法欺骗其它节点。</p>
</li>
<li><p>交易透明，双方匿名</p>
<p>区块链的运行规则是公开透明的，所有的数据信息也是公开的，因此每一笔交易都对所有节点可见。由于节点与节点之间是去信任的，因此节点之间无需公开身份，每个参与的节点都是匿名的。</p>
</li>
<li><p>不可篡改，可追溯</p>
<p>单个甚至多个节点对数据库的修改无法影响其他节点的数据库，除非能控制整个网络中超过51%的节点同时修改，这几乎不可能发生。区块链中的每一笔交易都通过密码学方法与相邻两个区块串联，因此可以追溯到任何一笔交易的前世今生。</p>
</li>
</ol>
<h2 id="3、智能合约和共识机制"><a href="#3、智能合约和共识机制" class="headerlink" title="3、智能合约和共识机制"></a>3、智能合约和共识机制</h2><p>引用 <a href="https://developer.aliyun.com/article/822304">区块链之旅(三)智能合约与共识机制</a></p>
<p><strong>智能合约</strong></p>
<blockquote>
<p>智能合约是一套以数字形式定义的约定，包括合约参与方可以在上面执行这些约定的协议。智能合约的基本思想是，各种各样的合约条款可以嵌入到我们使用的硬件和软件中，从而使得攻击者需要很大的代价去攻击。</p>
</blockquote>
<p><strong>共识机制</strong></p>
<blockquote>
<p>由于点对点网络下存在较高的网络时延，各个节点所观察到的事务先后顺序不可能完全一致。因此区块链系统需要设置一种机制对在差不多时间内发生的事务的先后顺序达成一致。这种对一个时间窗口内的事务的先后顺序达成共识的算法被称为共识机制。</p>
</blockquote>
<p>后面会单独说明智能合约和共识机制相关知识。</p>
<h2 id="4、区块链分类以及应用"><a href="#4、区块链分类以及应用" class="headerlink" title="4、区块链分类以及应用"></a>4、区块链分类以及应用</h2><ul>
<li>开放程度<ol>
<li>公有链：所有人可以参与的区块链，公平公开的，任何人都能够访问，发送，接受，认证交易，被认为是 “完全去中心化” 的区块链。代表链有：<em>BTC，ETH，EOS，蚂蚁链</em></li>
<li>私有链：由于害怕公有链被人为注入恶意内容或者失误后不可篡改挽回创建，被中心化机构控制，不具备去中心化属性，只能由创建者任意修改和操作，读取权限对外开放或者进行限制。代表链有：<em>Linux基金会以及Gem Health网络的超级账本项目（Hyperledger project）</em>，<em>R3 CEV</em>等。</li>
<li>联盟链：介于公有链和私有链，联盟区块链是指其共识过程受到预选节点控制的区块链；例如，不妨想象一个有15个金融机构组成的共同体，每个机构都运行着一个节点，而且为了使每个区块生效需要获得其中10个机构的确认（2/3确认）。区块链或许允许每个人都可读取，或者只受限于参与者，或走混合型路线。代表链：<em>R3</em>，<em>Hyperledger</em> ，长安链</li>
</ol>
</li>
<li>应用范围<ol>
<li>基础链</li>
<li>应用链</li>
</ol>
</li>
<li>原创性<ol>
<li>原链</li>
<li>分叉链</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">公有链</th>
<th align="center">联盟链</th>
<th align="center">私有链</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参与者</td>
<td align="center">不限</td>
<td align="center">联盟成员</td>
<td align="center">链的所有者</td>
</tr>
<tr>
<td align="center">共识机制</td>
<td align="center">PoW/PoS</td>
<td align="center">分布式一致性算法</td>
<td align="center">solo/pbft等</td>
</tr>
<tr>
<td align="center">验证者</td>
<td align="center">自愿提供算力或质押加密货币者</td>
<td align="center">联盟成员协商确定</td>
<td align="center">链的所有者</td>
</tr>
<tr>
<td align="center">激励机制</td>
<td align="center">需要</td>
<td align="center">可选</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">去中心化程度</td>
<td align="center">较高</td>
<td align="center">偏低</td>
<td align="center">极低</td>
</tr>
<tr>
<td align="center">如初特点</td>
<td align="center">解决<a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E9%87%8D%E6%94%AF%E4%BB%98">双重支付</a></td>
<td align="center">效率和成本优化</td>
<td align="center">安全性高、效率高</td>
</tr>
<tr>
<td align="center">吞吐量</td>
<td align="center">7笔/秒至数千笔/秒（<a href="https://zh.wikipedia.org/wiki/%E6%AF%8F%E7%A7%92%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E9%87%8F">TPS</a>）</td>
<td align="center">&lt;10万笔/秒（TPS）</td>
<td align="center">视配置决定</td>
</tr>
<tr>
<td align="center">应用领域</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/%E5%8D%80%E5%A1%8A%E9%8F%88%E9%81%8A%E6%88%B2">区块链游戏</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9D%9E%E5%90%8C%E8%B3%AA%E5%8C%96%E4%BB%A3%E5%B9%A3">非同质化代币</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E9%87%91%E8%9E%8D">去中心化金融</a>等</td>
<td align="center">供应链管理、金融服务、医疗保健等</td>
<td align="center">大型组织或私人企业之业务等</td>
</tr>
<tr>
<td align="center">代表项目</td>
<td align="center"><a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81">比特币</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%9D%8A">以太坊</a></td>
<td align="center">R3、<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E8%B4%A6%E6%9C%AC">Hyperledger</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="5、区块链的数据结构"><a href="#5、区块链的数据结构" class="headerlink" title="5、区块链的数据结构"></a>5、区块链的数据结构</h2><p>区块链是由多个区块组成，下面是一个区块的数据结构</p>
<p><img src="/assets/blockchain/one.jpg" alt="区块数据结构"></p>
<ul>
<li><p>区块高度：可以理解为每个区块的唯一ID，从0开始的 “创世块” （块高度为0），一段时间生成一个块，块高度+1.</p>
</li>
<li><p>头哈希：每一个区块都有一个唯一的哈希值，依据上一个区块的头哈希+数据块哈希+随机数生成</p>
</li>
<li><p>父哈希：上一个高度区块的哈希值（头哈希）</p>
</li>
<li><p>merkle根：区块中每一笔交易对应一个哈希，呈树状结构，生产的最终值（根），代表了改区块中的交易</p>
</li>
<li><p>难度：难度不是固定不变的，会随着网络现有算力调节。保持相对公平。</p>
</li>
<li><p>Nonce：挖矿所要达到的目标值</p>
</li>
<li><p>区块体：一定时间内所生成的交易信息，即账本</p>
</li>
</ul>
<p><img src="/assets/blockchain/two.jpg"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
</search>
